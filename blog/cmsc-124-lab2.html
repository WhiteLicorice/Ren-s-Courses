<!doctype html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><base href=/Ren-s-Courses/ ><script src="https://cdn.tailwindcss.com?plugins=typography"></script><script>tailwind.config={theme:{extend:{colors:{primary:tailwind.colors.red,"github-dark":"#24292e"},fontFamily:{sans:["Inter","ui-sans-serif","system-ui"],serif:["Merriweather","Georgia","serif"]}}}}</script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/katorlys/prism-theme-github/themes/prism-theme-github-dark.css><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/prism.min.js data-manual integrity="sha512-UOoJElONeUNzQbbKQbjldDf9MwOHqxNz49NNJJ1d90yp+X9edsHyJoAs6O4K19CZGaIdjI5ohK+O2y5lBTW6uQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/components/prism-python.min.js integrity="sha512-3qtI9+9JXi658yli19POddU1RouYtkTEhTHo6X5ilOvMiDfNvo6GIS6k2Ukrsx8MyaKSXeVrnIWeyH8G5EOyIQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/components/prism-nasm.min.js integrity="sha512-zdmZCKfEirT3AOxxgIwXpIyik7DSpYOnzXujg8duM6ICokx243tPnCTgqiQN+TAhLSMO2UF11C/+gO1DrI+A8A==" crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/components/prism-bash.min.js integrity="sha512-35RBtvuCKWANuRid6RXP2gYm4D5RMieVL/xbp6KiMXlIqgNrI7XRUh9HurE8lKHW4aRpC0TZU3ZfqG8qmQ35zA==" crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/components/prism-powershell.min.js integrity="sha512-dnJS1fxEUNZirzvtoG39P8JWa8DajX420LajzUbn+taV6hd9BfnHHgpPAWNADYjNRPT1Gt4v4/XGMULqi0uqVQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-kotlin.min.js></script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/plugins/show-language/prism-show-language.min.css integrity="sha512-09fmad4VA38AJxIRtkrW3DmKI2PsTsEpx3bfR8ZmkQunfQ9jORIieKVREv6fVLmqdnrFbPkCO5PKTnBIIvswBg==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/9000.0.1/plugins/show-language/prism-show-language.min.js integrity="sha512-WZeiH/5UJ3HZsxGBbWWIBluPrC/PIHbs/x1GtCP7lky8XbHXEzYfI9PJkL0d7/LdL7DvzHFScNkic8PaNhh+qg==" crossorigin=anonymous referrerpolicy=no-referrer></script><style>pre[class=language-]{position:relative;overflow:auto}pre[class*=language-][data-language] code{display:block;padding-top:1.5em}pre[class*=language-][data-language]::before{content:attr(data-language);color:#000;background-color:#cfcfcf;width:fit-content;white-space:nowrap;position:absolute;top:0;left:0;font-size:.9em;border-radius:0 0 5px 0;padding:0 .5em;text-shadow:none}</style><body class="min-h-screen min-h-full bg-github-dark font-serif text-gray-200"><div class="mx-auto max-w-3xl px-4 sm:px-6 xl:max-w-5xl xl:px-0"><div class="flex min-h-screen flex-col justify-between"><header class="flex items-center justify-between py-10"><div><a href><div class="flex items-center justify-between"><div class="h-6 text-2xl font-semibold sm:block text-primary-800">Ren&#x27;s Courses</div></div></a></div><div class="flex items-center space-x-4 leading-5 sm:space-x-6"><a href="" class="hidden font-medium text-gray-100 sm:block">Home </a><a href=tags class="hidden font-medium text-gray-100 sm:block">Materials </a><a href=https://github.com/WhiteLicorice/Ren-s-Courses class="hidden font-medium text-gray-100 sm:block"><svg xmlns=http://www.w3.org/2000/svg viewBox="0 0 24 24" class="hover:text-primary-400 h-6 w-6 fill-current text-gray-200"><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg></a><button id=toggle-button aria-label="Toggle Menu" class=sm:hidden><svg xmlns=http://www.w3.org/2000/svg viewBox="0 0 20 20" fill=currentColor class="h-8 w-8 text-gray-100"><path fill-rule=evenodd d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule=evenodd></path></svg></button><div id=mobile-menu class="fixed left-0 top-0 z-10 h-full w-full hidden translate-x-full transform duration-300 ease-in-out bg-gray-950 opacity-[0.98]"><div class="flex justify-end"><button id=close-mobile-menu-button class="mr-8 mt-11 h-8 w-8" aria-label="Toggle Menu"><svg xmlns=http://www.w3.org/2000/svg viewBox="0 0 20 20" fill=currentColor class=text-gray-100><path fill-rule=evenodd d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule=evenodd></path></svg></button></div><nav class="fixed mt-8 h-full"><div class="px-12 py-4"><a href="" class="text-2xl font-bold tracking-widest text-gray-100">Home</a></div><div class="px-12 py-4"><a href=tags class="text-2xl font-bold tracking-widest text-gray-100">Materials</a></div><div class="px-12 py-4"><a href=https://github.com/WhiteLicorice/Ren-s-Courses class="text-2xl font-bold tracking-widest text-gray-100"><svg xmlns=http://www.w3.org/2000/svg viewBox="0 0 24 24" class="hover:text-primary-400 h-6 w-6 fill-current text-gray-200"><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg></a></div></nav></div></div></header><script>const toggleMobileMenu=()=>{const e=document.querySelector("#mobile-menu");e.classList.toggle("translate-x-full"),e.classList.toggle("hidden")};document.querySelector("#toggle-button").addEventListener("click",toggleMobileMenu),document.querySelector("#close-mobile-menu-button").addEventListener("click",toggleMobileMenu)</script><main class=mb-auto><article><div class="xl:divide-y xl:divide-gray-700"><header class="pt-6 xl:pb-6"><div class="space-y-1 text-center"><dl class=space-y-10><div><dt class=sr-only>Published on<dd class="text-base font-medium leading-6 text-gray-400"><time datetime=2025-09-23T00:00:00.000>September 23, 2025</time></div></dl><div class="prose prose-invert mx-auto"><h1>Parser</h1></div></div></header><div class="grid-rows-[auto_1fr] divide-y pb-8 divide-gray-700 xl:grid xl:grid-cols-4 xl:gap-x-6 xl:divide-y-0"><dl class="pb-10 pt-6 xl:border-b xl:pt-11 xl:border-gray-700"><dt class=sr-only>Authors<dd><ul class="flex flex-wrap justify-center gap-4 sm:space-x-12 xl:block xl:space-x-0 xl:space-y-8"><li class="flex items-center space-x-2"><dl class="whitespace-nowrap text-sm font-medium leading-5"><dt class=sr-only>Name<dd class="text-gray-900 dark:text-gray-100 flex gap-1 items-center">Rene Andre Bedonia Jocsing<a target=_blank rel="noopener noreferrer" href=https://github.com/WhiteLicorice class="flex gap-1 items-center text-primary-500 hover:text-primary-600 dark:hover:text-primary-400"><svg xmlns=http://www.w3.org/2000/svg viewBox="0 0 24 24" class="hover:text-primary-400 w-4 h-4 fill-current text-gray-200"><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg></a><a target=_blank rel="noopener noreferrer" href="https://drive.google.com/file/d/1yK1grI29pnI8_2mIbrHFQB0N_9LQeYbt/view?usp=drive_link" class="flex gap-1 text-primary-500 hover:text-primary-600 dark:hover:text-primary-400"><svg xmlns=http://www.w3.org/2000/svg viewBox="0 0 24 24" class="hover:text-primary-400 w-4 h-4 fill-current text-gray-200"><path d="M6 2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6H6z M13 3.5L18.5 9H13V3.5z"></path></svg></a></dl></ul></dl><div class="divide-y divide-gray-700 xl:col-span-3 xl:row-span-2 xl:pb-0"><div class="prose prose-invert max-w-none pb-8 pt-10"><p>Welcome to the second leg of your language hacking journey. Now that your scanner can transform source code into tokens, it's time to build the next component: the <strong>parser</strong>. Think of parsing as the step where we take those tokens and figure out what they actually <em>mean</em> in the context of your programming language.<p>If the scanner answers, &quot;what are the words?&quot;, then the parser answers, &quot;how do the words fit together?&quot; To do this, a parser takes the array of tokens from your scanner and organizes them into a tree that represents the grammatical structure of your source code.<h2 id=from-token-arrays-to-expression-trees>From Token Arrays to Expression Trees</h2><p>Consider this simple mathematical expression:<pre><code>2 + 3 * 4
</code></pre><p>Your scanner may break this up into tokens: <code>NUMBER(2)</code>, <code>PLUS</code>, <code>NUMBER(3)</code>, <code>STAR</code>, <code>NUMBER(4)</code>. But how do you parse these tokens? Note that a linear sequence doesn't capture the crucial fact that, in math, multiplication has higher precedence than addition. With just an array of tokens, you could make the mistake of evaluating 2 plus 3 first (you probably even did this once in your math series!). Hence, it is the parser's job is to organize these tokens into a tree that reflects the correct mathematical meaning. The parser should produce something like this.<pre><code>   +
  / \
 2   *
    / \
   3   4
</code></pre><p>This tree structure, called an <strong>Abstract Syntax Tree (AST)</strong>, makes the precedence explicit. We go from the bottom-most, left-most leaves up to the root. In this example, we must evaluate the multiplication first (3 * 4), then add 2 to the result.<h2 id=context-free-grammars>Context-Free Grammars</h2><p>Before we can build a parser, we first need to formalize the rules that govern how tokens can be combined. We do this by using a <strong>Context-Free Grammar (CFG)</strong>. Don't let the fancy name intimidate you. In mathematics and, by extension, computer science, it's just a systematic way of describing the syntax rules of some language.<p>A CFG consists of:<ul><li><strong>Terminals</strong>: The actual tokens from your scanner (like <code>NUMBER</code>, <code>PLUS</code>, <code>STAR</code>) (denoted by quotes)<li><strong>Non-terminals</strong>: Abstract categories that represent groups of tokens (like &quot;expression&quot; or &quot;term&quot;, denoted by the absence of quotes)<li><strong>Production rules</strong>: Rules that define how non-terminals can be broken down into sequences of terminals and other non-terminals</ul><p>Here's a simple grammar for arithmetic expressions, defined by production rules that yield both terminals and non-terminals.<pre><code>expression → equality
equality   → comparison ( ( &quot;!=&quot; | &quot;==&quot; ) comparison )*
comparison → term ( ( &quot;&gt;&quot; | &quot;&gt;=&quot; | &quot;&lt;&quot; | &quot;&lt;=&quot; ) term )*
term       → factor ( ( &quot;-&quot; | &quot;+&quot; ) factor )*
factor     → unary ( ( &quot;/&quot; | &quot;*&quot; ) unary )*
unary      → ( &quot;!&quot; | &quot;-&quot; ) unary | primary
primary    → NUMBER | STRING | &quot;true&quot; | &quot;false&quot; | &quot;nil&quot; | &quot;(&quot; expression &quot;)&quot;
</code></pre><p><em>The fact that recursion is convenient allows us to form a combinatorically large number of strings from a limited grammar.</em><p>Each line is a production rule and yields a valid string in your programming language (a line of your source code). The symbol before the arrow is a non-terminal, and the stuff after the arrow (read: &quot;produces&quot;) shows what it can be replaced with, separated by a pipe &quot;|&quot; (read: &quot;or&quot;). You can choose whichever terminal or non-terminal among the grouped, pipe-separated choices when you evaluate a production rule. So, if you were doing this by hand, you'd replace <code>expression</code> with <code>equality</code> in a statement, and keep on replacing non-terminals (starting from the left-most) until the string becomes composed entirely of terminals. The <code>*</code> means &quot;zero or more&quot;, <code>+</code> means &quot;one or more&quot;, and <code>?</code> means &quot;zero or one&quot; (optional). Parentheses group choices together. Note that a parenthesis in quotes is interpreted as the parenthesis <em>character</em>!<p>Let's trace through parsing <code>2 + 3</code> by hand (get a piece of paper so you can follow).<ol><li>Start with <code>expression</code><li>Replace with <code>equality</code> (only choice)<li>Replace with <code>comparison</code> (no equality operators present)<li>Replace with <code>term</code> (no comparison operators present)<li>Replace with <code>factor ( ( &quot;-&quot; | &quot;+&quot; ) factor )*</code><li>The first <code>factor</code> becomes <code>unary</code>, then <code>primary</code>, then <code>NUMBER(2)</code><li>We have a <code>+</code>, so we match the <code>*</code> part once<li>The second <code>factor</code> becomes <code>NUMBER(3)</code><li>Final result: a <code>term</code> containing <code>NUMBER(2) + NUMBER(3)</code></ol><p>Note, however, that a grammar can be ambiguous. Consider this simpler grammar.<pre><code>expression → expression &quot;+&quot; expression | NUMBER
</code></pre><p>For the input <code>1 + 2 + 3</code>, this grammar allows two different parse trees. Can you trace why?<pre><code>      +           +
     / \    OR   / \
    1   +       +   3
       / \     / \
      2   3   1   2
</code></pre><p>The left tree represents <code>1 + (2 + 3)</code> while the right represents <code>(1 + 2) + 3</code>. This ambiguity makes the grammar unsuitable for a parser (because what if instead of plus it was multiply?). To solve ambiguity, we must structure our grammar carefully to enforce <strong>precedence</strong> and <strong>associativity</strong>.<h2 id=precedence-and-associativity>Precedence and Associativity</h2><p>Notice how the first grammar in the previous section is structured from lowest to highest precedence. Equality operations (like <code>==</code>) have lower precedence than comparisons (like <code>&gt;</code>), which have lower precedence than addition and subtraction. Addition and subtraction then have lower precedence than multiplication and division. Unary operations like &quot;!&quot; and &quot;--&quot; have the second highest precedence. Primary has the highest precedence among all because these are your literals like numbers, strings, booleans, etc. or specially enforced groupings via parenthesis.<p>The grammar's hierarchy ensures that <code>2 + 3 * 4</code> parses as <code>2 + (3 * 4)</code> rather than <code>(2 + 3) * 4</code>. It accomplishes this by separating each categorical operation into their own production rule (think separation of concerns from CMSC 22!) and arranging them according to precedence (think which symbol you'd read first if you were parsing it yourself).<p>The grammar also handles associativity. Most binary operators are left-associative, meaning <code>1 - 2 - 3</code> should parse as <code>(1 - 2) - 3</code>. The way we structure the recursive rules in our grammar naturally creates left-associative parsing (but you can try to structure right-associative parsing, if you wish).<h2 id=recursive-descent-parsing>Recursive Descent Parsing</h2><p>At the heart of this lab, you'll implement what's called a <strong>recursive descent parser</strong>. This is a top-down parsing technique where each grammar rule becomes a method in your parser class. The beauty of this approach is that your code mirrors your grammar almost exactly. Because of this, recursive descent parsers are the most beginner-friendly among parsing techniques. But don't underestimate it! Recursive descent parsers are used in production for gcc, JavaScript engines, and C# parsers because they're fast, robust, and easy to implement. If C++ can be parsed using a recursive descent parser, it should work for your programming language, too.<p>To parse a stream of tokens, we must transform our grammar rules into code. Consider that, in a recursive descent parser, the <code>term</code> rule from before,<pre><code>term       → factor ( ( &quot;-&quot; | &quot;+&quot; ) factor )*
</code></pre><p>becomes a <code>term</code> method that:<ol><li>Calls the <code>factor</code> method to parse the left operand<li>While the current token is <code>+</code> or <code>-</code>:<ul><li>Saves the operator<li>Calls <code>factor</code> again to parse the right operand<li>Creates a binary expression node with left operand, operator, and right operand<li>Makes this new node the left operand for the next iteration</ul><li>Returns the final expression</ol><h2 id=translating-grammar-rules-to-code>Translating Grammar Rules to Code</h2><p>Each production rule in your grammar translates directly to a method in your parser. Here are some common patterns that you can adopt.<p><strong>Simple sequence</strong> (<code>unary → ( &quot;!&quot; | &quot;-&quot; ) unary | primary</code>):<pre><code>function unary():
    if current token is &quot;!&quot; or &quot;-&quot;:
        save the operator
        recursively call unary() for operand
        return UnaryNode(operator, operand)
    else:
        return primary()
</code></pre><p><strong>Repetition with <code>*</code></strong> (<code>term → factor ( ( &quot;-&quot; | &quot;+&quot; ) factor )*</code>):<pre><code>function term():
    expr = factor()
    
    while current token is &quot;-&quot; or &quot;+&quot;:
        save the operator
        right = factor()
        expr = BinaryNode(expr, operator, right)
    
    return expr
</code></pre><p><strong>Repetition with <code>+</code></strong> (<code>arguments → expression ( &quot;,&quot; expression )+</code>):<pre><code>function arguments():
    args = []
    args.add(expression())  // First one required
    
    while current token is &quot;,&quot;:
        consume &quot;,&quot;
        args.add(expression())
    
    return args
</code></pre><p><strong>Optional with <code>?</code></strong> (<code>function → &quot;fun&quot; IDENTIFIER &quot;(&quot; parameters? &quot;)&quot; block</code>):<pre><code>function parseFunction():
    expect &quot;fun&quot;
    name = expect IDENTIFIER
    expect &quot;(&quot;
    
    if current token is not &quot;)&quot;:
        params = parameters()  // Optional - only if present
    else:
        params = empty list
    
    expect &quot;)&quot;
    body = block()
    return FunctionNode(name, params, body)
</code></pre><p>Notice that <code>*</code> becomes <code>while</code>, <code>+</code> becomes &quot;do once, then while&quot;, and <code>?</code> becomes <code>if</code>.<h2 id=the-abstract-syntax-tree>The Abstract Syntax Tree</h2><p>Your parser's output will be an Abstract Syntax Tree—a tree data structure where each node represents a construct in your programming language. You'll need classes for different types of expressions. For example:<ul><li><strong>Literal</strong>: Represents literal values like numbers, strings, booleans<li><strong>Unary</strong>: Represents unary expressions like <code>-x</code> or <code>!flag</code><li><strong>Binary</strong>: Represents binary expressions like <code>a + b</code> or <code>x == y</code><li><strong>Grouping</strong>: Represents parenthesized expressions like <code>(2 + 3)</code></ul><h2 id=error-handling>Error Handling</h2><p>Real-world code often has syntax errors, so your parser needs to handle them gracefully. When your parser encounters an unexpected token, it should:<ol><li>Report a clear error message indicating what was expected<li>Avoid crashing the entire parsing process<li>Continue parsing to find additional errors (rather than stopping at the first one)</ol><p>For now, focus on basic error detection and reporting. We'll tackle more sophisticated error recovery techniques in the interpreter labs.<h2 id=laboratory-deliverables>Laboratory Deliverables</h2><h3 id=context-free-grammar>Context-Free Grammar</h3><p>Draft a CFG for your programming language. To do this, <strong>add a &quot;Grammar&quot; section to your README.md in your GitHub repository</strong>. The CFG must be <strong>unambiguous</strong> and must capture the grammar rules of your programming language accurately.<h3 id=parser>Parser</h3><p>Building upon your previous lab, implement a complete recursive descent parser that can parse a stream of tokens according to the grammar of your language. Your parser should:<ul><li>Take the list of tokens from your scanner as input<li>Build an Abstract Syntax Tree representing the parsed expression<li>Handle operator precedence correctly<li>Support grouping with parentheses<li>Include basic error reporting for malformed expressions (unbalanced parenthesis, etc.)</ul><h3 id=ast-printer>AST Printer</h3><p>Create an AST printer that can traverse your syntax tree and output a string representation. Pretty printing will help you visualize and debug your parser. The pretty printer should output expressions in a format like:<pre><code>(+ 1.0 (* 2.0 3.0))
</code></pre><p>This parenthesized representation makes the tree structure explicit and is useful for testing.<h3 id=integration>Integration</h3><p>Modify your main program to use both the scanner and parser together:<ol><li>Scanner converts source code to tokens<li>Parser converts tokens to an AST<li>AST printer displays the parsed structure</ol><p>Your REPL should now show the parsed representation of expressions rather than just the raw tokens. This improved REPL is the expected, testable output for this laboratory.<h3 id=testing>Testing</h3><p>Create comprehensive test cases that demonstrate:<ul><li>Correct precedence handling<li>Left associativity of binary operators<li>Proper parsing of literals and grouping<li>Error handling for malformed expressions</ul><p>This time, you'll be providing the test cases and you'll be demonstrating the correctness of your parser during defense.<p>To close, remember to commit your changes to your GitHub repository with meaningful messages. Continue building on the same repository from your scanner lab. Good luck!<h2 id=expected-output>Expected Output</h2><pre><code>&gt; 42
42.0
&gt; &quot;Hello&quot;
Hello
&gt; true
true
&gt; nil
nil
&gt; 1 + 2
(+ 1.0 2.0)
&gt; 3 - 4 * 5
(- 3.0 (* 4.0 5.0))
&gt; --10
(- (- 10.0))
&gt; (1 + 2) == (3 - 0)
(== (group (+ 1.0 2.0)) (group (- 3.0 0.0)))
&gt; (1 + 2) * 3
(* (group (+ 1.0 2.0)) 3.0)
&gt; -(4 + 5)
(- (group (+ 4.0 5.0)))
&gt; 1 + 2 * 3 - 4
(- (+ 1.0 (* 2.0 3.0)) 4.0)
&gt; 10 + -5 * 15 - 6
(- (+ 10.0 (* (- 5.0) 15.0)) 6.0)
&gt; 1 &lt;= 2 != 3 &gt;= 4
(!= (&lt;= 1.0 2.0) (&gt;= 3.0 4.0))
&gt; 5 &gt; 3
(&gt; 5.0 3.0)
&gt; !true
(! true)
&gt; !!false
(! (! false))
&gt; &quot;hello&quot; != &quot;world&quot;
(!= hello world)
&gt; &quot;CMSC 124 is the best&quot;
CMSC 124 is the best
&gt; (1 + 2 + 3 + 4 + 5
[line 1] Error at end: Expect ')' after expression.
&gt; this is nonsense
[line 1] Error at 'this': Expect expression.
&gt; // just a comment, no code
[line 1] Error at end: Expect expression.
</code></pre><hr><h1 id=rubric-for-programming-exercises-50-pts>Rubric for Programming Exercises (50 pts)</h1><table><thead><tr><th><strong>Criteria (10 Points Each)</strong><th><strong>Excellent (9-10)</strong><th><strong>Good (6-8)</strong><th><strong>Fair (3-5)</strong><th><strong>Poor (0-2)</strong><tbody><tr><td><strong>Program Correctness</strong><td>Program executes correctly with no syntax or runtime errors, meets/exceeds specifications, and displays correct output<td>Program executes and outputs with minor errors, yet meets specifications<td>Program executes and outputs with major errors, yet somehow meets specifications<td>Program does not execute or does not meet specs<tr><td><strong>Logical Design</strong><td>Program is logically well-designed with excellent structure and flow<td>Program has slight logic errors that do not significantly affect the results<td>Program has significant logic errors affecting functionality<td>Program logic is fundamentally incorrect<tr><td><strong>Code Mastery</strong><td>Programmer demonstrates excellent mastery over the program's code<td>Programmer demonstrates adequate mastery over the program's code<td>Programmer demonstrates fair mastery over the program's code<td>Programmer demonstrates poor mastery over the program's code<tr><td><strong>Engineering Standards</strong><td>Program is stylistically well designed from an engineering standpoint<td>Slight inappropriate design choices (i.e., poor variable names, improper indentation)<td>Severe inappropriate design choices (i.e., code repetition, redundancy)<td>Program is poorly written<tr><td><strong>Documentation</strong>*<td>Program is well-documented: comments exist for clarity, not redundancy<td>Missing one required comment or some redundant comments<td>Missing two or more required comments or many redundant comments<td>Most documentation missing or most documentation is redundant</table><p>*<strong>Remember: &quot;Code tells you how, comments tell you why.&quot;</strong> — Jeff Atwood, co-founder of Stack Overflow and Discourse</div></div><footer><div class="text-sm font-medium leading-5 divide-gray-700 xl:col-start-1 xl:row-start-2 xl:divide-y"><div class="py-4 xl:py-8"><h2 class="text-xs uppercase tracking-wide text-gray-400">Tags</h2><div class="flex flex-wrap"><a class="text-primary-500 hover:text-primary-400 mr-3 text-sm font-medium uppercase" href=tags/cmsc-124>cmsc-124</a></div></div></div><div class="pt-4 xl:pt-8"><a class="text-primary-500 hover:text-primary-400" aria-label="Back to the home" href>← Back to home</a></div></footer></div></div></article><script>Prism.highlightAll()</script></main><footer><div class="mt-16 flex flex-col items-center"><div class="mb-3 flex space-x-4"><a class="text-sm text-gray-500 transition hover:text-gray-600" target=_blank rel="noopener noreferrer" href=https://github.com/WhiteLicorice/Ren-s-Courses><span class=sr-only>github</span> <svg xmlns=http://www.w3.org/2000/svg viewBox="0 0 24 24" class="hover:text-primary-400 h-6 w-6 fill-current text-gray-200"><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg></a></div><div class="mb-2 flex space-x-2 text-sm text-gray-400"><a target=_blank rel="noopener noreferrer" href=https://github.com/BlazorStatic/BlazorStatic>Powered by Blazor</a><div>•</div><div>© 2025</div></div></div></footer></div></div><blazor-focus-on-navigate selector=h1></blazor-focus-on-navigate>
