// /**
//  * CRITICAL THEME INITIALIZATION (IIFE)
//  * * Executed immediately when the script is parsed, blocking the main thread 
//  * briefly to apply the user's preferred theme before the DOM fully renders.
//  * * Purpose: Prevents the "Flash of Unstyled Content" (FOUC) where the 
//  * default theme flashes before the saved theme loads.
//  */
// (function () {
//     try {
//         var localTheme = localStorage.getItem('user-theme');
//         if (localTheme) {
//             document.documentElement.setAttribute('data-theme', localTheme);
//         }
//     } catch (e) {
//         console.warn("localStorage is disabled.")
//         // Silently fail if localStorage is disabled/inaccessible, ugh.
//     }
// })();

/**
 * PWA SERVICE WORKER REGISTRATION
 * * Registers the service worker to enable Progressive Web App features 
 * (offline caching, installability) if the browser supports it.
 */
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('js/service-worker.js')
            .then(registration => {
                console.log('PWA ServiceWorker registered: ', registration.scope);
            })
            .catch(error => {
                console.log('PWA ServiceWorker registration failed: ', error);
            });
    });
}

/**
 * ENHANCE MARKDOWN CODE BLOCKS
 * * Scans for <pre> blocks generated by the Markdown parser and adds UI enhancements.
 * * Features:
 * 1. Wraps <pre> in a .code-wrapper div for styling.
 * 2. Adds a language label (e.g., "C#", "BASH") based on Prism classes.
 * 3. Injects a "Copy to Clipboard" button with success animation.
 * 4. Triggers Prism.js syntax highlighting on the modified DOM.
 */
window.addCodeFeatures = () => {
    // Map short codes to display names
    const langMap = {
        'cs': 'c#', 'csharp': 'c#', 'cpp': 'c++', 'c': 'c', 'py': 'python', 'python': 'python',
        'js': 'js', 'javascript': 'js', 'ts': 'ts', 'typescript': 'ts', 'html': 'html', 'xml': 'xml',
        'json': 'json', 'yaml': 'yaml', 'md': 'markdown', 'bash': 'bash', 'sh': 'sh',
        'powershell': 'powershell', 'nasm': 'asm', 'asm': 'asm', 'gdscript': 'gdscript'
    };

    // SVG Icons
    const iconCopy = `<rect width="8" height="4" x="8" y="2" rx="1" ry="1"/><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/>`;
    const iconCheck = `<polyline points="20 6 9 17 4 12"/>`;

    // Select code blocks inside the typography container (.prose)
    const preBlocks = document.querySelectorAll('.prose pre');

    preBlocks.forEach(pre => {
        // Prevent double-wrapping if function runs twice
        if (pre.parentElement.classList.contains('code-wrapper')) return;

        // 1. Create Wrapper
        const wrapper = document.createElement('div');
        wrapper.className = 'code-wrapper';
        pre.parentElement.insertBefore(wrapper, pre);
        wrapper.appendChild(pre);

        // 2. Add Language Label
        const className = [...pre.classList].find(c => c.startsWith('language-'));
        if (className) {
            const rawLang = className.replace('language-', '').toLowerCase();
            const label = langMap[rawLang] || rawLang;
            wrapper.setAttribute('data-language', label);
        }

        // 3. Create Copy Button
        const btn = document.createElement('button');
        btn.className = 'copy-button';
        btn.ariaLabel = "Copy code";
        btn.innerHTML = `<svg viewBox="0 0 24 24">${iconCopy}</svg>`;

        btn.addEventListener('click', () => {
            const code = pre.querySelector('code');
            if (!code) return;

            navigator.clipboard.writeText(code.innerText).then(() => {
                // Success State
                btn.classList.add('copied');
                btn.innerHTML = `<svg viewBox="0 0 24 24">${iconCheck}</svg>`;

                // Revert after 2s
                setTimeout(() => {
                    btn.classList.remove('copied');
                    btn.innerHTML = `<svg viewBox="0 0 24 24">${iconCopy}</svg>`;
                }, 2000);
            }).catch(err => {
                console.error('Copy failed:', err);
            });
        });

        wrapper.appendChild(btn);
    });

    // 4. Trigger Highlighting
    if (window.Prism) {
        window.Prism.highlightAll();
    }
};

/**
 * GENERATE DYNAMIC TABLE OF CONTENTS (TOC)
 * * Scans article headers (H1-H3) and builds a sidebar navigation menu.
 * Includes "ScrollSpy" logic to highlight the active section while scrolling.
 * * Styling: Uses semantic CSS variables (text-accent, border-muted) to support multiple themes.
 */
window.generateTOC = () => {
    const prose = document.querySelector('.prose');
    const tocContainer = document.getElementById('toc-content');
    const mobileTocContainer = document.getElementById('mobile-toc-content');

    // Exit if no content or no TOC containers exist
    if (!prose || (!tocContainer && !mobileTocContainer)) return;

    // Grab Main Title + Content Headers
    const mainTitle = document.querySelector('article h1');
    const contentHeaders = Array.from(prose.querySelectorAll('h1, h2, h3'));
    const headers = mainTitle ? [mainTitle, ...contentHeaders] : contentHeaders;

    if (headers.length === 0) return;

    // Helper: Builds the UL/LI structure
    const createList = () => {
        const ul = document.createElement('ul');
        ul.className = 'flex flex-col gap-2 font-mono text-xs text-text-dim';

        headers.forEach((header, index) => {
            // Generate ID if missing (required for anchor links)
            if (!header.id) {
                header.id = header.innerText
                    .toLowerCase()
                    .replace(/[^a-z0-9]+/g, '-')
                    .replace(/(^-|-$)/g, '');
                if (!header.id) header.id = `section-${index}`;
            }

            const li = document.createElement('li');
            const a = document.createElement('a');

            a.href = `#${header.id}`;
            a.innerText = header.innerText;
            a.className = 'block truncate transition-colors duration-200 hover:text-accent';
            a.dataset.target = header.id;

            // Indentation based on hierarchy
            if (header.tagName === 'H1') {
                a.classList.add('border-l', 'border-border-muted');
            }
            else if (header.tagName === 'H2') {
                a.classList.add('border-l', 'border-border-muted');
                a.style.paddingLeft = '12px';
            }
            else if (header.tagName === 'H3') {
                a.classList.add('border-l', 'border-border-muted');
                a.style.paddingLeft = '24px';
            }

            // Click Handler: Smooth Scroll
            a.addEventListener('click', (e) => {
                e.preventDefault();
                if (header === mainTitle) {
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                } else {
                    header.scrollIntoView({ behavior: 'smooth' });
                }
                history.pushState(null, null, `#${header.id}`);
            });

            li.appendChild(a);
            ul.appendChild(li);
        });
        return ul;
    };

    // Inject TOC into DOM
    if (tocContainer) { tocContainer.innerHTML = ''; tocContainer.appendChild(createList()); }
    if (mobileTocContainer) { mobileTocContainer.innerHTML = ''; mobileTocContainer.appendChild(createList()); }

    // ScrollSpy: IntersectionObserver to highlight active section
    if (tocContainer) {
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const id = entry.target.id;

                    // Reset all links
                    tocContainer.querySelectorAll('a').forEach(link => {
                        link.classList.remove('text-accent', 'border-accent', 'font-medium');
                        if (link.classList.contains('border-l')) link.classList.add('border-border-muted');
                    });

                    // Activate current link
                    const activeLink = tocContainer.querySelector(`a[data-target="${id}"]`);
                    if (activeLink) {
                        activeLink.classList.add('text-accent', 'font-medium');
                        if (activeLink.classList.contains('border-l')) {
                            activeLink.classList.remove('border-border-muted');
                            activeLink.classList.add('border-accent');
                        }
                    }
                }
            });
        }, { rootMargin: '-100px 0px -66% 0px' }); // Offset to trigger highlight slightly before section hits top

        headers.forEach(h => observer.observe(h));
    }
};

/**
 * INITIALIZE SCROLL-TO-TOP BUTTON
 * * Manages the visibility of the FAB (Floating Action Button).
 * Logic:
 * 1. Hide when near top of page.
 * 2. Show when scrolling UP.
 * 3. Hide when scrolling DOWN (to clear view while reading).
 */
window.initScrollButton = () => {
    const btn = document.getElementById('scroll-btn');
    if (!btn) return;

    let lastScrollY = window.scrollY;
    let isScrolling;

    const updateButton = () => {
        const currentScrollY = window.scrollY;
        const showThreshold = 300; // Pixels from top before button enables

        if (currentScrollY < showThreshold) {
            // Near Top: Always Hide
            btn.classList.add('opacity-0', 'pointer-events-none', 'translate-y-4');
            btn.classList.remove('opacity-100', 'translate-y-0');
        }
        else {
            if (currentScrollY < lastScrollY) {
                // Scrolling UP: Show
                btn.classList.remove('opacity-0', 'pointer-events-none', 'translate-y-4');
                btn.classList.add('opacity-100', 'translate-y-0');
            }
            else {
                // Scrolling DOWN: Hide
                btn.classList.add('opacity-0', 'pointer-events-none', 'translate-y-4');
                btn.classList.remove('opacity-100', 'translate-y-0');
            }
        }
        // Prevent negative scroll values (iOS bounce effect)
        lastScrollY = currentScrollY > 0 ? currentScrollY : 0;
    };

    // Throttle scroll events via requestAnimationFrame
    window.addEventListener('scroll', () => {
        if (!isScrolling) {
            window.requestAnimationFrame(() => {
                updateButton();
                isScrolling = false;
            });
            isScrolling = true;
        }
    });

    btn.addEventListener('click', () => {
        window.scrollTo({ top: 0, behavior: 'smooth' });
    });
};

/**
 * MAIN ENTRY POINT
 * Initializes all dynamic features once the DOM is ready.
 */
document.addEventListener("DOMContentLoaded", () => {
    window.addCodeFeatures();
    window.generateTOC();
    window.initScrollButton();
});